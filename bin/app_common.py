import base64
import json
import os
import hashlib
import datetime
from configparser import ConfigParser
import requests
import time
from time import sleep

helper = None

def set_helper(hlp):
    global helper
    helper = hlp


def extractCID(token):
    encode_str = token.split('.')[1]
    # add padding
    encode_str += '=='
    try:
        decode_str = base64.b64decode(encode_str)
        data = json.loads(decode_str)
        cid = data['cid']
    except Exception:
        cid = 'unknown'
    return cid


def get_version():
    VERSION_DIR = os.path.join(
        os.environ["SPLUNK_HOME"], 'etc', 'apps', 'vision_one_splunk', 'default', 'app.conf')
    if not os.path.exists(VERSION_DIR):
        return 0
    app_config = ConfigParser()
    app_config.read(VERSION_DIR, encoding='UTF-8')
    return app_config['launcher']['version']


def set_input_setting(section, key, value):
    local_path = os.path.join(
        os.environ["SPLUNK_HOME"], 'etc', 'apps', 'vision_one_splunk', 'local')
    if not os.path.exists(local_path):
        os.makedirs(local_path, 0o755)

    setting_path = os.path.join(local_path, 'inputs.conf')
    input_config = ConfigParser()
    input_config.read(setting_path, encoding='UTF-8')
    if not input_config.has_section(section):
        input_config.add_section(section)
    input_config.set(section, key, value)
    with open(setting_path, 'w') as file:
        input_config.write(file)


def format_iso_time(ft_rule='%Y-%m-%dT%H:%M:%SZ', delta_sec=0):
    calc_time = datetime.datetime.utcnow() - datetime.timedelta(seconds=delta_sec)
    return calc_time.strftime(ft_rule)


def format_timestamp(delta_sec=0):
    calc_time = datetime.datetime.now() - datetime.timedelta(seconds=delta_sec)
    return int(calc_time.timestamp())


def timestamp2iso(timestamp, ft_rule='%Y-%m-%dT%H:%M:%S.000Z'):
    # timestamp is generated by datetime.datetime.now(), so contains time zone information
    return time.strftime(ft_rule, time.gmtime(timestamp))


def isotime_delta(t1, t2, ft_rule="%Y-%m-%dT%H:%M:%SZ"):
    # t2 must bigger than t1
    t1 = datetime.datetime.strptime(t1, ft_rule)
    t2 = datetime.datetime.strptime(t2, ft_rule)
    if t1 > t2:
        raise Exception("t2 must bigger than t1")
    result = int((t2-t1).total_seconds())
    return result


def timerange_split(start, end, interval, ft_rule="%Y-%m-%dT%H:%M:%SZ"):
    result = []
    time_delta = isotime_delta(start, end, ft_rule)
    if not time_delta > interval:
        return [(start, end)]

    start = datetime.datetime.strptime(start, ft_rule)
    end = datetime.datetime.strptime(end, ft_rule)
    cursor = start + datetime.timedelta(seconds=interval)
    while cursor <= end:
        result.append((start.strftime(ft_rule), cursor.strftime(ft_rule)))
        start = cursor
        cursor += datetime.timedelta(seconds=interval)
    if start < end:
        result.append((start.strftime(ft_rule), end.strftime(ft_rule)))
    return result


def gen_context_path(input_name):
    encode_str = base64.b64encode(bytes(input_name, 'utf-8'))
    suffix = hashlib.sha1(encode_str).hexdigest()
    return (os.path.join(os.environ["SPLUNK_HOME"], 'etc', 'apps', 'vision_one_splunk', 'data'), 'status-{}.json'.format(suffix))


def fetch_context(input_name, init_val={}):
    ck_path, file_name = gen_context_path(input_name)
    status_file = os.path.join(ck_path, file_name)
    if not os.path.exists(ck_path):
        os.makedirs(ck_path, 0o755)
    if not os.path.exists(status_file):
        with open(status_file, 'w') as json_file:
            json.dump(init_val, json_file)
    else:
        try:
            with open(status_file) as json_file:
                status = json.load(json_file)
        except json.decoder.JSONDecodeError:
            helper.log_error(
                f"JSONDecodeError@{status_file} when fetch_context, INPUT:{input_name}")
            status = {}
        return status
    return init_val


def update_context(input_name, key, value):
    ck_path, file_name = gen_context_path(input_name)
    status_file = os.path.join(ck_path, file_name)
    if not os.path.exists(ck_path):
        os.makedirs(ck_path, 0o755)
    if not os.path.exists(status_file):
        with open(status_file, 'w') as json_file:
            status = {
                key: value
            }
            json.dump(status, json_file)
    else:
        try:
            with open(status_file) as json_file:
                status = json.load(json_file)
        except json.decoder.JSONDecodeError:
            helper.log_error(
                f"JSONDecodeError@{status_file} when update_context, INPUT:{input_name}")
            status = {}
        status[key] = value
        with open(status_file, 'w') as json_file:
            json.dump(status, json_file)
    return True


class RetryException(Exception):
    pass


class UnRetryException(Exception):
    pass


def raise_for_status(response):
    if isinstance(response.reason, bytes):
        # We attempt to decode utf-8 first because some servers
        # choose to localize their reason strings. If the string
        # isn't utf-8, we fall back to iso-8859-1 for all other
        # encodings. (See PR #3538)
        try:
            reason = response.reason.decode('utf-8')
        except UnicodeDecodeError:
            reason = response.reason.decode('iso-8859-1')
    else:
        reason = response.reason

    if 400 <= response.status_code < 500:
        http_error_msg = u'%s Client Error: %s for url: %s' % (
            response.status_code, reason, response.url)
        raise UnRetryException(http_error_msg)

    elif 500 <= response.status_code < 600:
        http_error_msg = u'%s Server Error: %s for url: %s' % (
            response.status_code, reason, response.url)
        raise RetryException(http_error_msg)


def request_help(max_retries,backoff_sec):
    def send_request(url,method,parameters=None,payload=None,headers=None, proxies=None,timeout=55):
        attempt_times, attempt_delay = max_retries, backoff_sec
        response = None
        while attempt_times >= 0:
            try:
                if "https" in url:
                    response = requests.request(method, url, params=parameters, headers=headers, json=payload, timeout=timeout,proxies=proxies)
                    raise_for_status(response)
                    return response
                else:
                    return "Error: URL protocol must be HTTPS"
            except RetryException as e:
                pass
            except UnRetryException as e:
                break
            attempt_times -= 1
            if attempt_times != 0:
                sleep(attempt_delay)

        return response

    return send_request


def update_tpc_metrics(endpoint, headers, proxies):
    try:
        tpc_req = request_help(2, 3)
        body = {
            "xdr_splunk_addon": {
                "metrics": {
                    "last_sync_time": format_timestamp()
                }
            },
        }
        res = None
        res = tpc_req(
            url=endpoint + "/external/v2/direct/tpc/external/tpc/cms/api/v1/connector/metrics",
            method="PUT",
            payload=body,
            headers=headers,
            proxies=proxies
        )
        res.raise_for_status()
    except Exception as e:
        resp_text = res.text
        helper.log_error(
            f"fail to update metrics to tpc with response: {resp_text}")
